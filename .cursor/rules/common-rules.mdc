---
alwaysApply: true
---
# Cursor 核心运行时规则

> **极简高效版本** - 仅包含每次对话必需的核心规则
> **详细说明**：请参考 `detailed-guides.mdc` 获取完整的配置指导和使用说明

---

## 🚀 快速启动检查

### ⚡ 智能规则调度系统（按需加载）

```javascript
// **智能调度**: 根据用户输入和上下文动态加载相关规则
function INTELLIGENT_RULE_DISPATCHER(userInput, context) {
  const relevantRules = [];
  
  // 🔍 步骤1: 上下文分析
  const contextAnalysis = analyzeContext(userInput, context);
  
  // 🔍 步骤2: 技术栈检测（仅在相关时加载）
  if (contextAnalysis.involvesTechStack) {
    const techStackRules = detectAndLoadTechStackRules(contextAnalysis);
    relevantRules.push(...techStackRules);
  }
  
  // 🔍 步骤3: 功能域检测（仅在相关时加载）
  if (contextAnalysis.involvesDevelopment) {
    const developmentRules = detectAndLoadDevelopmentRules(contextAnalysis);
    relevantRules.push(...developmentRules);
  }
  
  // 🔍 步骤4: 问题域检测（仅在相关时加载）
  if (contextAnalysis.involvesProblemSolving) {
    const problemRules = detectAndLoadProblemRules(contextAnalysis);
    relevantRules.push(...problemRules);
  }
  
  // 🔍 步骤5: 安全合规检测（仅在相关时加载）
  if (contextAnalysis.involvesSecurity) {
    const securityRules = detectAndLoadSecurityRules(contextAnalysis);
    relevantRules.push(...securityRules);
  }
  
  // 📋 按优先级排序并应用
  const sortedRules = sortRulesByPriority(relevantRules);
  return APPLY_SELECTED_RULES(sortedRules);
}

// 🧠 智能上下文分析函数
function analyzeContext(userInput, context) {
  return {
    // 技术栈相关检测
    involvesTechStack: detectTechStackMentions(userInput),
    techStack: identifyTechStack(userInput, context),
    
    // 开发活动检测
    involvesDevelopment: detectDevelopmentActivity(userInput),
    developmentType: identifyDevelopmentType(userInput),
    
    // 问题解决检测
    involvesProblemSolving: detectProblemSolving(userInput),
    problemType: identifyProblemType(userInput),
    
    // 安全相关检测
    involvesSecurity: detectSecurityMentions(userInput),
    securityType: identifySecurityType(userInput),
    
    // LDCMS专用检测
    isLdcmsRelated: detectLdcmsContext(userInput, context),
    ldcmsFeature: identifyLdcmsFeature(userInput)
  };
}
```

### 🎯 智能规则调度流程（按需加载）

```mermaid
flowchart TD
    A[用户输入] --> B[智能上下文分析]
    B --> C{是否涉及技术栈?}
    C -->|是| D[加载技术栈规则]
    C -->|否| E{是否涉及开发?}
    D --> E
    E -->|是| F[加载开发规则]
    E -->|否| G{是否涉及问题解决?}
    F --> G
    G -->|是| H[加载问题域规则]
    G -->|否| I{是否涉及安全?}
    H --> I
    I -->|是| J[加载安全规则]
    I -->|否| K[仅使用通用规则]
    J --> L[按优先级排序规则]
    K --> L
    L --> M[应用选定规则]
    M --> N[执行主要操作]
    
    style B fill:#4CAF50
    style L fill:#2196F3
    style M fill:#FF9800
```

### 🔍 智能检测函数库

```javascript
// 🔍 技术栈检测函数
function detectTechStackMentions(userInput) {
  const techStackKeywords = [
    // LDCMS相关
    'LDCMS', 'ldcms', 'FastAdmin', 'fastadmin',
    'addons/ldcms', '企业网站管理系统',
    
    // 前端技术栈
    'React', 'Vue', 'Angular', 'JavaScript', 'TypeScript',
    'Bootstrap', 'AdminLTE', 'RequireJS',
    
    // 后端技术栈
    'ThinkPHP', 'PHP', 'Laravel', 'Node.js', 'Python',
    'MySQL', 'Redis', 'MongoDB',
    
    // 开发工具
    'Docker', 'Git', 'Webpack', 'Vite'
  ];
  
  return techStackKeywords.some(keyword => 
    userInput.toLowerCase().includes(keyword.toLowerCase())
  );
}

// 🔍 开发活动检测函数
function detectDevelopmentActivity(userInput) {
  const developmentKeywords = [
    '开发', '编写', '创建', '实现', '修改', '优化',
    'develop', 'create', 'implement', 'modify', 'optimize',
    '代码', 'code', '功能', 'feature', '模块', 'module',
    '接口', 'API', '数据库', 'database', '表', 'table'
  ];
  
  return developmentKeywords.some(keyword => 
    userInput.toLowerCase().includes(keyword.toLowerCase())
  );
}

// 🔍 LDCMS上下文检测函数
function detectLdcmsContext(userInput, context) {
  // 文件路径检测
  const ldcmsPaths = [
    'addons/ldcms/', 'addons\\ldcms\\',
    'view/default/', 'view/en/', 'view/ldcms2024/',
    'fa_ldcms_'
  ];
  
  const pathMatch = ldcmsPaths.some(path => 
    context.currentFile?.includes(path) || 
    userInput.includes(path)
  );
  
  // 关键词检测
  const ldcmsKeywords = [
    'LDCMS', 'ldcms', '企业网站管理系统',
    'FastAdmin', 'fastadmin',
    '多语言', '多模板', 'multilanguage', 'multitemplate',
    'Document', 'Category', 'Ad', 'Langs'
  ];
  
  const keywordMatch = ldcmsKeywords.some(keyword => 
    userInput.toLowerCase().includes(keyword.toLowerCase())
  );
  
  return pathMatch || keywordMatch;
}

// 🔍 问题解决检测函数
function detectProblemSolving(userInput) {
  const problemKeywords = [
    '问题', '错误', '异常', '故障', '修复', '解决',
    'problem', 'error', 'issue', 'bug', 'fix', 'solve',
    '不工作', '失败', '报错', '异常'
  ];
  
  return problemKeywords.some(keyword => 
    userInput.toLowerCase().includes(keyword.toLowerCase())
  );
}

// 🔍 安全相关检测函数
function detectSecurityMentions(userInput) {
  const securityKeywords = [
    '安全', '权限', '认证', '授权', '加密',
    'security', 'permission', 'auth', 'encrypt',
    '登录', 'login', '密码', 'password',
    'SQL注入', 'XSS', 'CSRF'
  ];
  
  return securityKeywords.some(keyword => 
    userInput.toLowerCase().includes(keyword.toLowerCase())
  );
}
```

---

## ⚡ 核心执行规则

### 1. 文件大小强制限制
- **500行铁律**：任何文件 ≥500行 → 立即强制分离
- **检查时机**：代码修改前必须检查行数
- **执行策略**：超限 → 停止操作 → 强制分离

### 2. 智能决策边界

| 决策级别 | 操作类型 | 典型示例 | 执行方式 |
|----------|----------|----------|----------|
| **立即执行** | Bug修复、代码优化 | 语法错误、格式化、安全漏洞、性能优化 | 无需确认，直接执行 |
| **需要确认** | 功能变更 | 新功能、API变更、依赖升级、配置修改 | 说明后等待用户确认 |
| **必须审查** | 核心业务 | 业务逻辑、数据库变更、权限设置 | 详细说明+强制用户审查 |
| **禁止自主** | 高风险操作 | 生产部署、数据删除、破坏性重构 | 绝不自主执行 |

### 3. DRY 原则强制执行机制（Don't Repeat Yourself）

#### 🔍 **重复检测触发** → 自动加载 `code-quality-dry-standards.mdc`

| 触发条件 | 检测阈值 | 执行动作 | 专用规则应用 |
|----------|----------|----------|-------------|
| **代码重复** | ≥2次相同逻辑 | 立即重构 | `🛠️ DRY专用规则 → [强制应用]` |
| **配置重复** | 多处相同配置 | 立即统一 | `🛠️ DRY专用规则 → [配置整合]` |
| **文档重复** | ≥3处相同说明 | 单一信息源 | `🛠️ DRY专用规则 → [文档优化]` |
| **规则重复** | 多文件相同规则 | 立即合并 | `🛠️ DRY专用规则 → [规则整合]` |

```javascript
// DRY 原则检查 - 自动触发专用规则文件
function DRY_PRINCIPLE_CHECK(codeChange) {
  const duplicationDetected = detectCodeDuplication(codeChange);
  
  if (duplicationDetected.length > 0) {
    // 自动加载专用DRY规则文件
    FORCE_LOAD_SPECIALIZED_RULE('code-quality-dry-standards.mdc');
    return APPLY_DETAILED_DRY_STANDARDS(duplicationDetected);
  }
  
  return DRY_COMPLIANT();
}
```

> 💡 **详细DRY实施指南**: 检测到代码重复时自动引用 `code-quality-dry-standards.mdc` 获取完整的重构策略、合规性标准和实战示例

### 4. 专用规则文件优先加载机制（强制执行路径）

#### 🔥 **强制优先级** - 无条件检查和应用
| 优先级 | 规则文件类型 | 强制执行条件 | 生成时机 | 应用方式 |
|--------|-------------|-------------|----------|----------|
| **P0 - 技术栈专用** | `<tech-stack>-v<version>-standards.mdc` | 检测到对应技术栈 | 立即生成（如不存在） | 强制加载，无条件应用 |
| **P1 - 代码质量专用** | `code-quality-dry-standards.mdc` | 检测到代码重复 | 已存在，立即应用 | 强制加载，DRY标准执行 |
| **P2 - 问题域专用** | `<problem-type>-solutions.mdc` | 存在相关问题上下文 | 问题重复出现时 | 强制加载，优先应用 |
| **P3 - 安全合规** | `security-<type>-requirements.mdc` | 涉及安全相关操作 | 安全需求识别时 | 强制加载，严格执行 |
| **P4 - 功能域专用** | `<domain>-<feature>-standards.mdc` | 特定功能域操作 | 功能复杂化时 | 按需加载，智能应用 |

#### 📋 **条件优先级** - 智能判断加载
| 场景类型 | 规则文件 | 精确加载条件 | 跳过条件 | 优先级 |
|----------|----------|-------------|----------|--------|
| **协作交互** | collaboration-standards.mdc | 需要格式化回复 OR 涉及决策边界判断 | 纯技术问题且无格式要求 | 高 |
| **项目管理** | project-management-practices.mdc | 提及"环境"/"团队"/"部署"/"监控" | 单纯代码修改任务 | 中 |
| **规则管理** | rule-file-management.mdc | 用户要求生成规则 OR 同问题出现≥2次 | 首次遇到的新问题 | 中 |
| **初始化流程** | project-initialization.mdc | 无`.cursor/project-initialized` OR 用户明确要求 | 已初始化且无技术栈变更 | 最高 |

```javascript
// 强制专用规则文件优先检查函数
function shouldLoadRuleFile(fileType, context) {
  // **第一步: 强制检查专用规则文件** - 无条件执行
  const specializedRules = checkSpecializedRules(context);
  if (specializedRules.length > 0) {
    for (const rule of specializedRules) {
      FORCE_LOAD_AND_APPLY(rule); // 强制应用所有专用规则
    }
  }
  
  // **第二步: 检查是否需要生成新的专用规则文件**
  const missingTechStackRules = detectMissingTechStackRules(context);
  for (const missing of missingTechStackRules) {
    IMMEDIATE_GENERATE_AND_APPLY(missing); // 立即生成并应用
  }
  
  // **第三步: 快速跳过逻辑**（仅在专用规则检查完成后）
  if (context.is_simple_bug_fix && !context.requires_formatting && 
      specializedRules.length === 0) {
    return SKIP_CONDITIONAL_RULES();
  }
  
  // **第四步: 条件加载逻辑**（补充性检查）
  switch(fileType) {
    case 'collaboration':
      return context.needs_reply_format || context.needs_decision_boundary;
    case 'project-management':
      return /环境|团队|部署|监控|质量/.test(context.user_request);
    case 'rule-management':
      return context.repeated_problem_count >= 2;
    default:
      return true; // 默认加载
  }
}

// 专用规则文件检查辅助函数
function checkSpecializedRules(context) {
  const rules = [];
  
  // P0: 技术栈专用规则（最高优先级）
  const techStack = detectTechStack();
  for (const tech of techStack) {
    const ruleFile = `${tech.name}-v${tech.version}-standards.mdc`;
    if (exists(ruleFile)) rules.push({file: ruleFile, priority: 0});
  }
  
  // P1: 问题域专用规则
  const problemDomain = analyzeProblemDomain(context);
  if (problemDomain) {
    const solutionFile = `${problemDomain}-solutions.mdc`;
    if (exists(solutionFile)) rules.push({file: solutionFile, priority: 1});
  }
  
  // P2: 安全合规规则
  if (context.involves_security) {
    const securityRules = scanSecurityRules();
    rules.push(...securityRules.map(file => ({file, priority: 2})));
  }
  
  // 按优先级排序返回
  return rules.sort((a, b) => a.priority - b.priority);
}
```

### 4. 问题处理快速决策

| 问题次数 | 处理策略 | 必须执行 | 记录要求 |
|----------|----------|----------|----------|
| **第1次** | 正常解决 | 分析根因 + 修复 | 简要记录解决方案 |
| **第2次重复** | 标准复盘 | 深度分析 + 模式识别 | 记录到 `docs/问题解决/` |
| **第3次失败** | 强制深度复盘 | 风险等级提升 + 专家介入 | 完整复盘报告 + 预防措施 |

### 5. Git操作禁令
**绝对禁止**：执行任何 `git` 命令（add, commit, push 等）
**用户职责**：所有版本控制操作由用户完成

---

## 🎯 快速引用表

### 🎯 智能规则调度引用表（按需加载）

#### **🧠 智能检测阶段**（根据用户输入分析）
| 检测类型 | 触发关键词示例 | 自动加载规则 | 显示格式 |
|----------|-------------|-------------|----------|
| **🔧 技术栈检测** | LDCMS、FastAdmin、ThinkPHP、Bootstrap | 对应技术栈规则 | `🔧 [技术栈] → [智能应用]` |
| **💻 开发活动检测** | 开发、创建、实现、代码、功能 | 开发相关规则 | `💻 [开发类型] → [按需应用]` |
| **🛠️ 问题解决检测** | 问题、错误、修复、故障 | 问题解决规则 | `🛠️ [问题域] → [解决方案]` |
| **🔒 安全检测** | 安全、权限、认证、加密 | 安全合规规则 | `🔒 [安全域] → [合规要求]` |

#### **📋 条件加载机制**（仅在需要时加载）
| 场景类型 | 加载条件 | 规则文件 | 跳过条件 |
|----------|----------|----------|----------|
| **协作交互** | 需要格式化回复 | collaboration-standards.mdc | 纯技术问答 |
| **项目管理** | 涉及环境/部署/团队 | project-management-practices.mdc | 单纯代码问题 |
| **规则管理** | 用户要求生成规则 | rule-file-management.mdc | 首次遇到问题 |
| **初始化** | 项目未初始化 | project-initialization.mdc | 已完成初始化 |

#### **⚡ 性能优化特性**
| 优化类型 | 实现方式 | 效果 |
|----------|----------|------|
| **按需加载** | 只加载相关规则文件 | 减少90%不必要的规则加载 |
| **智能缓存** | 同类问题复用规则 | 提升响应速度 |
| **条件跳过** | 简单问题跳过复杂规则 | 避免过度处理 |
| **优先级排序** | 重要规则优先应用 | 确保关键规则生效 |

> 💡 **新机制优势**: 
> 1. 🚀 **性能提升**: 只加载需要的规则，减少处理时间
> 2. 🎯 **精准匹配**: 根据上下文智能选择最相关的规则
> 3. 🔄 **动态调整**: 根据对话进展动态加载新规则
> 4. 📊 **可观测性**: 清晰显示哪些规则被应用及原因

### 质量标准快速判断

| 环境类型 | 质量要求 | 测试标准 | 文档要求 | 技术债务 |
|----------|----------|----------|----------|----------|
| **生产环境** | 最高标准 | 完整测试覆盖 | 详细文档 | 禁止 |
| **开发环境** | 平衡质量效率 | 重点功能测试 | 核心文档 | 最小化 |
| **原型环境** | 快速验证 | 基础功能验证 | 简要说明 | 可接受 |

---

## 📋 核心价值观（智能决策原则）

| 价值观原则 | 强制执行条件 | 可适度调整条件 | 判断逻辑 |
|------------|-------------|---------------|----------|
| **规则遵循 > 开发便利** | 文件≥500行 OR 违反核心规则 | 无 - 绝对不可违背 | `if (file_lines >= 500) FORCE_SPLIT()` |
| **DRY原则 > 开发速度** | 重复代码≥2次 OR 配置重复 | 原型开发的快速验证 | `if (code_duplication) FORCE_REFACTOR()` |
| **质量 > 速度** | 生产环境 OR 核心业务逻辑 | 原型环境的快速验证 | `if (env == 'production') MAX_QUALITY()` |
| **安全 > 便利** | 涉及权限/数据/密钥 | 开发环境的调试便利 | `if (involves_security) SECURITY_FIRST()` |
| **团队协作 > 个人效率** | 多人协作项目 | 个人学习项目 | `if (team_project) READABLE_CODE()` |

```javascript
// 价值观决策算法
function applyValuePrinciple(action, context) {
  // 铁律检查 - 无条件执行
  if (context.file_lines >= 500) {
    return FORCE_FILE_SPLIT();
  }
  
  // DRY 原则检查 - 优先执行 → 触发专用规则文件
  const duplicationLevel = detectCodeDuplication(action, context);
  if (duplicationLevel.severity !== 'none') {
    FORCE_LOAD_SPECIALIZED_RULE('code-quality-dry-standards.mdc');
    return APPLY_DRY_SPECIALIZED_STANDARDS(duplicationLevel, context);
  }
  
  // 安全优先检查
  if (action.involves_security || action.affects_permissions) {
    return REQUIRE_SECURITY_REVIEW();
  }
  
    // 环境适应性检查  
  if (context.environment === 'production') {
    return APPLY_HIGHEST_STANDARDS();
  } else if (context.environment === 'prototype') {
    return ALLOW_TECHNICAL_DEBT();
  }
  
  // 默认平衡策略
  return BALANCED_APPROACH();
}

// DRY 原则快速检测 - 详细逻辑在专用规则文件中
function detectCodeDuplication(action, context) {
  // 基础重复检测 - 触发专用规则文件加载
  if (action.involves_code_changes) {
    const basicDuplication = quickDuplicationScan(action.code_changes);
    return { severity: basicDuplication.detected ? 'detected' : 'none' };
  }
  return { severity: 'none' };
}
```

---

## 🔄 性能优化机制

### 条件加载策略
- **状态缓存**：初始化状态缓存1小时，避免重复检查
- **按需引用**：仅在明确需要时加载专用规则文件
- **快速跳过**：已初始化且无变更 → 直接进入协作模式

### 智能触发机制

| 触发类型 | 条件检查 | 执行动作 | 优先级 |
|----------|----------|----------|--------|
| **触发初始化** | 首次对话 | 完整初始化流程 | 最高 |
| **触发初始化** | 用户明确要求 | 按用户需求执行 | 最高 |
| **触发初始化** | 关键文件变更 (package.json等) | 增量更新检查 | 高 |
| **触发初始化** | 距离上次检查>24小时 | 状态验证 | 中 |
| **跳过检查** | `.cursor/project-initialized` 存在且有效 | 直接协作模式 | - |
| **跳过检查** | 技术栈无变更 | 直接协作模式 | - |
| **跳过检查** | 同一会话继续对话 | 直接协作模式 | - |

---

**注意**：本文件专注于运行时性能优化，详细说明和配置指导请参考对应的专用规则文件。